# Comprobación de la orquestación de Daniel Bautista (@danielbc09)

La documentación de la comprobación de mi orquestación por Daniel se puede encontrar [aquí]().

## Creación de máquinas virtuales y su provisionamiento

Se ha empezado por crear y provisionar la máquina virtual del servicio principal de Daniel. Como se puede leer en [su repositorio](https://github.com/danielbc09/Proyecto_CC#despliegue), su servicio principal consiste en un servicio de usuarios de autobuses, que soporta operaciones CRUD sobre los mismos mediante una REST API. Con el comando `vagrant up servicio`, la máquina se ha creado y provisionado en unos minutos. Se puede ver [aquí](https://github.com/migueldgoncalves/CCproj_1819/blob/master/docs/Comprobacion_Hito5/images_provision_MiguelGoncalves_2/Provisionamiento_servicio_1.png) la creación con éxito, y [aquí](https://github.com/migueldgoncalves/CCproj_1819/blob/master/docs/Comprobacion_Hito5/images_provision_MiguelGoncalves_2/Provisionamiento_servicios_2.png) el provisionamiento con éxito.

Con la máquina del microservicio creada y provisionada, se ha creado y provisionado la segunda máquina virtual de Daniel, la de la base de datos PostgreSQL. El comando utilizado fue `vagrant up database`. La creación de la máquina virtual ha tenido éxito; sin embargo la última task de su playbook de Ansible ha fallado, la que reiniciaría el servicio `postgresql` dentro de esa máquina. Intentar repetir el provisionamiento con el comando `vagrant provision database` tiene éxito excepto para dicha task, como se puede ver [aquí](https://github.com/migueldgoncalves/CCproj_1819/blob/master/docs/Comprobacion_Hito5/images_provision_MiguelGoncalves_2/Provisionamiento_datos_1.png) y [aquí](https://github.com/migueldgoncalves/CCproj_1819/blob/master/docs/Comprobacion_Hito5/images_provision_MiguelGoncalves_2/Provisionamiento_datos_2.png). Ese es un comportamiento esperado, como me ha dicho Daniel, por lo que el paso siguiente ha sido acceder a la máquina virtual de base de datos vía SSH con el comando `vagrant ssh database` y reiniciar dicho servicio manualmente con el comando `sudo service postgresql restart`. Como se puede ver [aquí](https://github.com/migueldgoncalves/CCproj_1819/blob/master/docs/Comprobacion_Hito5/images_provision_MiguelGoncalves_2/Datos_restart.png), se ha tenido éxito en eso.

## Ejecución del servicio

Enseguida, para arrancar el servicio se ha entrado en la máquina virtual del mismo con el comando `vagrant ssh servicio`. Un último paso antes del arranque del servicio ha sido acceder al fichero `/etc/environment` y añadirle 3 variables de entorno, conteniendo el URL de la máquina de base de datos; el nombre de usuario previamente creado en ella; y respectiva contraseña. Ejecutando el comando `source /etc/environment` dichas variables se hacen efectivas para la consola.

El objetivo de Daniel al hacerlo fue introducir seguridad real en su proyecto, no accediendo a la base de datos como root ni con un usuario creado por defecto, sino con un usuario 'estándar' creado en el provisionamiento de la máquina de la base de datos mediante variables de entorno en la máquina local cuyos valores nunca son escritos en los ficheros de la aplicación. Se tarda más tiempo a orquestar los servicios, pero se aumenta la seguridad, aún más importante porque ambas máquinas están expuestas a toda la Internet. Creo que ha sido inteligente y pertinente de la parte de Daniel introducir estas medidas de seguridad.

El servicio se ejecuta con el comando `sudo mvn spring-boot:run`; en el fin se puede ver que se han creado con éxito 3 usuarios en el servicio. El output inicial se puede ver [aquí](https://github.com/migueldgoncalves/CCproj_1819/blob/master/docs/Comprobacion_Hito5/images_provision_MiguelGoncalves_2/Servicio_ejecutando_1.png), la máquina se queda ejecutando después de imprimir [este](https://github.com/migueldgoncalves/CCproj_1819/blob/master/docs/Comprobacion_Hito5/images_provision_MiguelGoncalves_2/Servicio_ejecutando_2.png) output.

Accediendo a la [ruta raíz](https://github.com/migueldgoncalves/CCproj_1819/blob/master/docs/Comprobacion_Hito5/images_provision_MiguelGoncalves_2/Web_1.png) de la aplicación en la dirección IP de la máquina del servicio principal, se puede ver entre otras cosas `{ status:"OK" }`, asegurando que el microservicio está correctamente desplegado. En la ruta `/user` se puede [ver](https://github.com/migueldgoncalves/CCproj_1819/blob/master/docs/Comprobacion_Hito5/images_provision_MiguelGoncalves_2/Web_2.png) los 3 usuarios creados previamente, accedendo a la ruta `/user/2` se puede [ver](https://github.com/migueldgoncalves/CCproj_1819/blob/master/docs/Comprobacion_Hito5/images_provision_MiguelGoncalves_2/Web_3.png) la información apenas del segundo usuario. Accediendo a un usuario inexistente, por ejemplo con la ruta `/user/4`, se devuelve un JSON personalizado con un mensaje de error indicando que el usuario no fue encontrado, como se puede ver [aquí](https://github.com/migueldgoncalves/CCproj_1819/blob/master/docs/Comprobacion_Hito5/images_provision_MiguelGoncalves_2/Web_3.png). El esquema de la base de datos se puede encontrar [aquí](https://github.com/migueldgoncalves/CCproj_1819/blob/master/docs/Comprobacion_Hito5/images_provision_MiguelGoncalves_2/Web_4.png).
